import sys
from pathlib import Path
from flask import Flask, jsonify, request, send_from_directory, Response
from flask_restful import Api, Resource
from flask_swagger_ui import get_swaggerui_blueprint
from flask_cors import CORS
import logging
import subprocess
import os

app = Flask(__name__)
CORS(app)

api = Api(app)

# Swagger configuration
SWAGGER_URL = '/swagger-ui'
API_URL = '/static/swagger.json'
swaggerui_blueprint = get_swaggerui_blueprint(
    SWAGGER_URL,
    API_URL,
    config={
        'app_name': "WrapperCSV API"
    }
)

app.register_blueprint(swaggerui_blueprint, url_prefix=SWAGGER_URL)


# Define the root project directory
root_dir = Path(__file__).resolve().parents[3]
sys.path.append(str(root_dir))

from BackEnd.Wrappers.Wrapper_CSV import process_csv

class WrapperCSVExecute(Resource):
    """
    WrapperCSVExecute is a Flask-RESTful resource that handles the execution of a CSV to JSON transformation script.

    Methods
    -------
    post():
        Executes the main.py script with the 'csv' argument and handles any subprocess errors.
    """

    def post(self):
        """
        Executes the main.py script with the 'csv' argument using python3 or py command.

        This method attempts to run the main.py script located in the root directory of the project with the 'csv' argument.
        If the python3 command fails, it tries to execute the script using the py command. If both commands fail, it returns
        an error response.

        Returns
        -------
        dict
            A dictionary containing an error message if the subprocess fails.
        int
            HTTP status code 500 if the subprocess fails.
        """
        #Execute the Wrapper_CSV.py
        process_csv()
        
        # Define the path to the output file
        output_file_path = root_dir / 'Resultados' / 'CSVtoJSON_Corregido.json'
        
        # Print the path to the output file for debugging purposes
        print("Path to output file:", output_file_path)
        
        # Read the output file and return its contents
        try:
            with open(output_file_path, 'r', encoding='utf-8') as output_file:
                output_data = output_file.read()
            return Response(output_data, mimetype='application/json')
        except FileNotFoundError:
            return {"error": "Output file not found"}, 404
        except Exception as e:
            return {"error": f"An error occurred while reading the output file: {e}"}, 500

    def delete(self):
        """
        Deletes the output JSON file generated by the CSV to JSON transformation script.

        This method attempts to delete the output JSON file located in the 'Resultados' directory. If the file is not found,
        it returns a 404 error response. If any other error occurs, it returns a 500 error response.

        Returns
        -------
        dict
            A dictionary containing a success message if the file is deleted successfully, or an error message if the file
            is not found or another error occurs.
        int
            HTTP status code 200 if the file is deleted successfully, 404 if the file is not found, or 500 if another error occurs.
        """
        output_file_path = root_dir / 'Resultados' / 'CSVtoJSON_Corregido.json'
        try:
            os.remove(output_file_path)
            return {"message": "Output file deleted successfully"}
        except FileNotFoundError:
            return {"error": "Output file not found"}, 404
        except Exception as e:
            return {"error": f"An error occurred while deleting the output file: {e}"}, 500

class WrapperCSVLog(Resource):
    """
    WrapperCSVLog is a Flask-RESTful resource that handles the retrieval and deletion of log files.

    Methods
    -------
    get_estadisticas():
        Retrieves the statistics log file content.
    get_rechazados():
        Retrieves the rejected entries log file content.
    get_reparados():
        Retrieves the repaired entries log file content.
    delete_estadisticas():
        Clears the statistics log file.
    delete_rechazados():
        Clears the rejected entries log file.
    delete_reparados():
        Clears the repaired entries log file.
    delete():
        Clears all log files.
    """

    def get_estadisticas(self):
        """
        Retrieves the statistics log file content.
        """
        log_file_path = root_dir / 'Resultados' / 'log-csv' / 'log-estadisticas-csv.log'
        try:
            with open(log_file_path, 'r', encoding='utf-8') as log_file:
                log_data = log_file.read()
            return Response(log_data, mimetype='text/plain', status='200')
        except FileNotFoundError:
            return {"error": "Log de estadísticas no encontrado"}, 404
        except Exception as e:
            return {"error": f"Error al leer el log de estadísticas: {e}"}, 500

    def delete_estadisticas(self):
        """
        Clears the statistics log file.
        """
        log_file_path = root_dir / 'Resultados' / 'log-csv' / 'log-estadisticas-csv.log'
        try:
            if log_file_path.exists():
                open(log_file_path, 'w').close()
            return {"message": "Log de estadísticas limpiado exitosamente"}
        except Exception as e:
            return {"error": f"Error al limpiar el log de estadísticas: {e}"}, 500

    def get_rechazados(self):
        """
        Retrieves the rejected entries log file content.
        """
        log_file_path = root_dir / 'Resultados' / 'log-csv' / 'log-rechazados-csv.log'
        try:
            with open(log_file_path, 'r', encoding='utf-8') as log_file:
                log_data = log_file.read()
            return Response(log_data, mimetype='text/plain', status='200')
        except FileNotFoundError:
            return {"error": "Log de rechazados no encontrado"}, 404
        except Exception as e:
            return {"error": f"Error al leer el log de rechazados: {e}"}, 500

    def delete_rechazados(self):
        """
        Clears the rejected entries log file.
        """
        log_file_path = root_dir / 'Resultados' / 'log-csv' / 'log-rechazados-csv.log'
        try:
            if log_file_path.exists():
                open(log_file_path, 'w').close()
            return {"message": "Log de rechazados limpiado exitosamente"}
        except Exception as e:
            return {"error": f"Error al limpiar el log de rechazados: {e}"}, 500

    def get_reparados(self):
        """
        Retrieves the repaired entries log file content.
        """
        log_file_path = root_dir / 'Resultados' / 'log-csv' / 'log-reparados-csv.log'
        try:
            with open(log_file_path, 'r', encoding='utf-8') as log_file:
                log_data = log_file.read()
            return Response(log_data, mimetype='text/plain', status='200')
        except FileNotFoundError:
            return {"error": "Log de reparados no encontrado"}, 404
        except Exception as e:
            return {"error": f"Error al leer el log de reparados: {e}"}, 500

    def delete_reparados(self):
        """
        Clears the repaired entries log file.
        """
        log_file_path = root_dir / 'Resultados' / 'log-csv' / 'log-reparados-csv.log'
        try:
            if log_file_path.exists():
                open(log_file_path, 'w').close()
            return {"message": "Log de reparados limpiado exitosamente"}
        except Exception as e:
            return {"error": f"Error al limpiar el log de reparados: {e}"}, 500

    def delete(self):
        """
        Clears all log files content.
        """
        log_files = [
            root_dir / 'Resultados' / 'log-csv' / 'log-estadisticas-csv.log',
            root_dir / 'Resultados' / 'log-csv' / 'log-rechazados-csv.log',
            root_dir / 'Resultados' / 'log-csv' / 'log-reparados-csv.log'
        ]
        
        try:
            for log_file_path in log_files:
                if log_file_path.exists():
                    open(log_file_path, 'w').close()
            return {"message": "Todos los archivos de log han sido limpiados exitosamente"}
        except Exception as e:
            return {"error": f"Error al limpiar los archivos de log: {e}"}, 500

# Add the resources to the API
api.add_resource(WrapperCSVExecute, '/wrapperCSV/execute')

# Add new endpoints for each log type
class WrapperCSVLogEstadisticas(Resource):
    def get(self):
        return WrapperCSVLog().get_estadisticas()
    def delete(self):
        return WrapperCSVLog().delete_estadisticas()

class WrapperCSVLogRechazados(Resource):
    def get(self):
        return WrapperCSVLog().get_rechazados()
    def delete(self):
        return WrapperCSVLog().delete_rechazados()

class WrapperCSVLogReparados(Resource):
    def get(self):
        return WrapperCSVLog().get_reparados()
    def delete(self):
        return WrapperCSVLog().delete_reparados()

class WrapperCSVLogClear(Resource):
    def delete(self):
        return WrapperCSVLog().delete()

api.add_resource(WrapperCSVLogEstadisticas, '/wrapperCSV/log/estadisticas')
api.add_resource(WrapperCSVLogRechazados, '/wrapperCSV/log/rechazados')
api.add_resource(WrapperCSVLogReparados, '/wrapperCSV/log/reparados')
api.add_resource(WrapperCSVLogClear, '/wrapperCSV/log')

#http://localhost:8082/swagger-ui/
if __name__ == '__main__':
    print("\n" + "="*50)
    print("API WrapperCSV iniciada exitosamente!")
    print("="*50)
    print("\nDocumentación disponible en:")
    print("  → http://localhost:8080/swagger-ui")
    print("\nEndpoints disponibles:")
    print("  → POST   http://localhost:8080/wrapperCSV/execute")
    print("  → GET    http://localhost:8080/wrapperCSV/log/estadisticas")
    print("  → DELETE http://localhost:8080/wrapperCSV/log/estadisticas")
    print("  → GET    http://localhost:8080/wrapperCSV/log/rechazados")
    print("  → DELETE http://localhost:8080/wrapperCSV/log/rechazados")
    print("  → GET    http://localhost:8080/wrapperCSV/log/reparados")
    print("  → DELETE http://localhost:8080/wrapperCSV/log/reparados")
    print("  → DELETE http://localhost:8080/wrapperCSV/log")
    print("\nPresiona Ctrl+C para detener el servidor")
    print("="*50 + "\n")
    app.run(debug=True, host='localhost', port=8080)